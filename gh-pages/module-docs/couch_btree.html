<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
lang="en" xml:lang="en">
<head>
<title>couch_btree</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2011-12-19 Mon"/>
<meta name="author" content="Robert Dionne"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">

<h1 class="title">couch_btree</h1>


<div id="outline-container-1" class="outline-3">
<h3 id="sec-1">Overview </h3>
<div class="outline-text-3" id="text-1">

<p>CouchDB btree is not a btree in the classical
<a href="http://en.wikipedia.org/wiki/B-tree#Technical_description">sense</a> of having
an order and maintaining lower and upper bounds on the number of nodes
at each level, but this is due to the append only nature of couchdb
and the MVCC model. In place updates are not performed so you won't
see the usual splitting and merging of nodes. Whenever a leaf node is
updated the entire path from the leaf to the root is also written
anew. However it is certainly a btree in providing log access and the
use of branching at each level to minimize the amount of disk
access. It's more or less self-balancing in the way an initial btree
might be populated by establishing a chunk size that determines how
many keys are packed into each chunk and letting that drive the
branching as branches are built up from the bottom (.eg. see <a href="http://en.wikipedia.org/wiki/Introduction_to_Algorithms">Cormen and Rivest</a> for an algorithm like this). It also stores information
(data sizes, deletes, and reductions) in the interior nodes. <a href="http://en.wikipedia.org/wiki/Donald_Knuth">Knuth, Volume 3 Sorting and Searching</a> is arguably a definitive reference. The
<a href="http://guide.couchdb.org/draft/btree.html">couchdb</a> reference book also has a brief discussion of it's
use of btrees.
</p>
<p>
One of the real elegant pieces in this module is the recursive nature
of <a href="#query_modify">query_modify</a> which handles lookups, inserts, and deletes whilst
walking down the tree.
</p>
</div>

</div>

<div id="outline-container-2" class="outline-3">
<h3 id="sec-2">The Code </h3>
<div class="outline-text-3" id="text-2">





<pre class="example">
-module(couch_btree).

-export([open/2, open/3, query_modify/4, add/2, add_remove/3]).
-export([fold/4, full_reduce/1, final_reduce/2, size/1, foldl/3, foldl/4]).
-export([fold_reduce/4, lookup/2, get_state/1, set_options/2]).
-export([less/3]).

-include("couch_db.hrl").
-define(CHUNK_THRESHOLD, 16#4ff).

</pre>




<p>
Extract and Assemble tranform various erlang structures to and from
key-value pairs, .eg. <a href="https://github.com/bdionne/couchdb/blob/couch-docs/src/couchdb/couch_db_updater.erl#L325">btree_by_id_split</a> and <a href="https://github.com/bdionne/couchdb/blob/couch-docs/src/couchdb/couch_db_updater.erl#L346">btree_by_id_join</a> are
one such pair of extract/assemble pairs used by in couch_db_updater
for the by_id btree.
</p>



<pre class="example">
extract(#btree{extract_kv=Extract}, Value) -&gt;
    Extract(Value).

assemble(#btree{assemble_kv=Assemble}, Key, Value) -&gt;
    Assemble(Key, Value).

less(#btree{less=Less}, A, B) -&gt;
    Less(A, B).

</pre>



<p>
This version of open I believe is only used in testing
</p>


<pre class="example">% pass in 'nil' for State if a new Btree.
open(State, Fd) -&gt;
    {ok, #btree{root=State, fd=Fd}}.
</pre>





<p>
Setting the options is a typical erlang function that recursively
walks a list, updating the btree record as it goes along until the
options list is empty.
</p>



<pre class="example">
set_options(Bt, []) -&gt;
    Bt;
set_options(Bt, [{split, Extract}|Rest]) -&gt;
    set_options(Bt#btree{extract_kv=Extract}, Rest);
set_options(Bt, [{join, Assemble}|Rest]) -&gt;
    set_options(Bt#btree{assemble_kv=Assemble}, Rest);
set_options(Bt, [{less, Less}|Rest]) -&gt;
    set_options(Bt#btree{less=Less}, Rest);
set_options(Bt, [{reduce, Reduce}|Rest]) -&gt;
    set_options(Bt#btree{reduce=Reduce}, Rest);
set_options(Bt, [{compression, Comp}|Rest]) -&gt;
    set_options(Bt#btree{compression=Comp}, Rest).
</pre>





<p>
When a btree is opened, for example in <a href="https://github.com/bdionne/couchdb/blob/couch-docs/src/couchdb/couch_db_updater.erl#L441">couch_db_updater</a> a file
descriptor is passed along with a group of options. Note that in the
case of couch_db_updater, the names for the extract and assemble
functions have nothing to do with splits and joins as those names are
used in the literature. What these functions do is serialize and
deserialize the erlang records used to hold the documents. In this
case the by_id btree uses full_doc_info records and the by_seq
btree doc_info records.
</p>



<pre class="example">

open(State, Fd, Options) -&gt;
    {ok, set_options(#btree{root=State, fd=Fd}, Options)}.

get_state(#btree{root=Root}) -&gt;
    Root.

</pre>





<pre class="example">
final_reduce(#btree{reduce=Reduce}, Val) -&gt;
    final_reduce(Reduce, Val);
final_reduce(Reduce, {[], []}) -&gt;
    Reduce(reduce, []);
final_reduce(_Bt, {[], [Red]}) -&gt;
    Red;
final_reduce(Reduce, {[], Reductions}) -&gt;
    Reduce(rereduce, Reductions);
final_reduce(Reduce, {KVs, Reductions}) -&gt;
    Red = Reduce(reduce, KVs),
    final_reduce(Reduce, {[], [Red | Reductions]}).

</pre>





<pre class="example">

fold_reduce(#btree{root=Root}=Bt, Fun, Acc, Options) -&gt;
    Dir = couch_util:get_value(dir, Options, fwd),
    StartKey = couch_util:get_value(start_key, Options),
    EndKey = case couch_util:get_value(end_key_gt, Options) of
        undefined -&gt; couch_util:get_value(end_key, Options);
        LastKey -&gt; LastKey
    end,
    KeyGroupFun = couch_util:get_value(key_group_fun, Options, fun(_,_) -&gt; true end),
    {StartKey2, EndKey2} =
    case Dir of
        rev -&gt; {EndKey, StartKey};
        fwd -&gt; {StartKey, EndKey}
    end,
    try
        {ok, Acc2, GroupedRedsAcc2, GroupedKVsAcc2, GroupedKey2} =
            reduce_stream_node(Bt, Dir, Root, StartKey2, EndKey2, undefined, [], [],
            KeyGroupFun, Fun, Acc),
        if GroupedKey2 == undefined -&gt;
            {ok, Acc2};
        true -&gt;
            case Fun(GroupedKey2, {GroupedKVsAcc2, GroupedRedsAcc2}, Acc2) of
            {ok, Acc3} -&gt; {ok, Acc3};
            {stop, Acc3} -&gt; {ok, Acc3}
            end
        end
    catch
        throw:{stop, AccDone} -&gt; {ok, AccDone}
    end.

</pre>





<pre class="example">

full_reduce(#btree{root=nil,reduce=Reduce}) -&gt;
    {ok, Reduce(reduce, [])};
full_reduce(#btree{root=Root}) -&gt;
    {ok, element(2, Root)}.

</pre>





<pre class="example">
size(#btree{root = nil}) -&gt;
    0;
size(#btree{root = {_P, _Red}}) -&gt;
    % pre 1.2 format
    nil;
size(#btree{root = {_P, _Red, Size}}) -&gt;
    Size.

</pre>





<pre class="example">
% wraps a 2 arity function with the proper 3 arity function
convert_fun_arity(Fun) when is_function(Fun, 2) -&gt;
    fun
        (visit, KV, _Reds, AccIn) -&gt; Fun(KV, AccIn);
        (traverse, _K, _Red, AccIn) -&gt; {ok, AccIn}
    end;
convert_fun_arity(Fun) when is_function(Fun, 3) -&gt;
    fun
        (visit, KV, Reds, AccIn) -&gt; Fun(KV, Reds, AccIn);
        (traverse, _K, _Red, AccIn) -&gt; {ok, AccIn}
    end;
convert_fun_arity(Fun) when is_function(Fun, 4) -&gt;
    Fun.    % Already arity 4

</pre>





<pre class="example">
make_key_in_end_range_function(#btree{less=Less}, fwd, Options) -&gt;
    case couch_util:get_value(end_key_gt, Options) of
    undefined -&gt;
        case couch_util:get_value(end_key, Options) of
        undefined -&gt;
            fun(_Key) -&gt; true end;
        LastKey -&gt;
            fun(Key) -&gt; not Less(LastKey, Key) end
        end;
    EndKey -&gt;
        fun(Key) -&gt; Less(Key, EndKey) end
    end;
make_key_in_end_range_function(#btree{less=Less}, rev, Options) -&gt;
    case couch_util:get_value(end_key_gt, Options) of
    undefined -&gt;
        case couch_util:get_value(end_key, Options) of
        undefined -&gt;
            fun(_Key) -&gt; true end;
        LastKey -&gt;
            fun(Key) -&gt; not Less(Key, LastKey) end
        end;
    EndKey -&gt;
        fun(Key) -&gt; Less(EndKey, Key) end
    end.

</pre>





<pre class="example">

foldl(Bt, Fun, Acc) -&gt;
    fold(Bt, Fun, Acc, []).

foldl(Bt, Fun, Acc, Options) -&gt;
    fold(Bt, Fun, Acc, Options).


fold(#btree{root=nil}, _Fun, Acc, _Options) -&gt;
    {ok, {[], []}, Acc};
fold(#btree{root=Root}=Bt, Fun, Acc, Options) -&gt;
    Dir = couch_util:get_value(dir, Options, fwd),
    InRange = make_key_in_end_range_function(Bt, Dir, Options),
    Result =
    case couch_util:get_value(start_key, Options) of
    undefined -&gt;
        stream_node(Bt, [], Bt#btree.root, InRange, Dir,
                convert_fun_arity(Fun), Acc);
    StartKey -&gt;
        stream_node(Bt, [], Bt#btree.root, StartKey, InRange, Dir,
                convert_fun_arity(Fun), Acc)
    end,
    case Result of
    {ok, Acc2}-&gt;
        FullReduction = element(2, Root),
        {ok, {[], [FullReduction]}, Acc2};
    {stop, LastReduction, Acc2} -&gt;
        {ok, LastReduction, Acc2}
    end.

</pre>




</div>

</div>

<div id="outline-container-3" class="outline-3">
<h3 id="sec-3">Adding, deleting and looking up keys in the tree </h3>
<div class="outline-text-3" id="text-3">





<pre class="example">
add(Bt, InsertKeyValues) -&gt;
    add_remove(Bt, InsertKeyValues, []).

add_remove(Bt, InsertKeyValues, RemoveKeys) -&gt;
    {ok, [], Bt2} = query_modify(Bt, [], InsertKeyValues, RemoveKeys),
    {ok, Bt2}.

</pre>



<p>
<a name="query_modify" class="target">query_modify</a> 
</p>


<pre class="example">query_modify(Bt, LookupKeys, InsertValues, RemoveKeys) -&gt;
    #btree{root=Root} = Bt,
    InsertActions = lists:map(
        fun(KeyValue) -&gt;
            {Key, Value} = extract(Bt, KeyValue),
            {insert, Key, Value}
        end, InsertValues),
    RemoveActions = [{remove, Key, nil} || Key &lt;- RemoveKeys],
    FetchActions = [{fetch, Key, nil} || Key &lt;- LookupKeys],
    SortFun =
        fun({OpA, A, _}, {OpB, B, _}) -&gt;
            case A == B of
            % A and B are equal, sort by op.
            true -&gt; op_order(OpA) &lt; op_order(OpB);
            false -&gt;
                less(Bt, A, B)
            end
        end,
    Actions = lists:sort(SortFun, lists:append([InsertActions, RemoveActions, FetchActions])),
    {ok, KeyPointers, QueryResults} = modify_node(Bt, Root, Actions, []),
    {ok, NewRoot} = complete_root(Bt, KeyPointers),
    {ok, QueryResults, Bt#btree{root=NewRoot}}.

</pre>





<pre class="example">
% for ordering different operations with the same key.
% fetch &lt; remove &lt; insert
op_order(fetch) -&gt; 1;
op_order(remove) -&gt; 2;
op_order(insert) -&gt; 3.

</pre>





<pre class="example">
lookup(#btree{root=Root, less=Less}=Bt, Keys) -&gt;
    SortedKeys = lists:sort(Less, Keys),
    {ok, SortedResults} = lookup(Bt, Root, SortedKeys),
    % We want to return the results in the same order as the keys were input
    % but we may have changed the order when we sorted. So we need to put the
    % order back into the results.
    couch_util:reorder_results(Keys, SortedResults).

lookup(_Bt, nil, Keys) -&gt;
    {ok, [{Key, not_found} || Key &lt;- Keys]};
lookup(Bt, Node, Keys) -&gt;
    Pointer = element(1, Node),
    {NodeType, NodeList} = get_node(Bt, Pointer),
    case NodeType of
    kp_node -&gt;
        lookup_kpnode(Bt, list_to_tuple(NodeList), 1, Keys, []);
    kv_node -&gt;
        lookup_kvnode(Bt, list_to_tuple(NodeList), 1, Keys, [])
    end.

lookup_kpnode(_Bt, _NodeTuple, _LowerBound, [], Output) -&gt;
    {ok, lists:reverse(Output)};
lookup_kpnode(_Bt, NodeTuple, LowerBound, Keys, Output) when tuple_size(NodeTuple) &lt; LowerBound -&gt;
    {ok, lists:reverse(Output, [{Key, not_found} || Key &lt;- Keys])};
lookup_kpnode(Bt, NodeTuple, LowerBound, [FirstLookupKey | _] = LookupKeys, Output) -&gt;
    N = find_first_gteq(Bt, NodeTuple, LowerBound, tuple_size(NodeTuple), FirstLookupKey),
    {Key, PointerInfo} = element(N, NodeTuple),
    SplitFun = fun(LookupKey) -&gt; not less(Bt, Key, LookupKey) end,
    case lists:splitwith(SplitFun, LookupKeys) of
    {[], GreaterQueries} -&gt;
        lookup_kpnode(Bt, NodeTuple, N + 1, GreaterQueries, Output);
    {LessEqQueries, GreaterQueries} -&gt;
        {ok, Results} = lookup(Bt, PointerInfo, LessEqQueries),
        lookup_kpnode(Bt, NodeTuple, N + 1, GreaterQueries, lists:reverse(Results, Output))
    end.


lookup_kvnode(_Bt, _NodeTuple, _LowerBound, [], Output) -&gt;
    {ok, lists:reverse(Output)};
lookup_kvnode(_Bt, NodeTuple, LowerBound, Keys, Output) when tuple_size(NodeTuple) &lt; LowerBound -&gt;
    % keys not found
    {ok, lists:reverse(Output, [{Key, not_found} || Key &lt;- Keys])};
lookup_kvnode(Bt, NodeTuple, LowerBound, [LookupKey | RestLookupKeys], Output) -&gt;
    N = find_first_gteq(Bt, NodeTuple, LowerBound, tuple_size(NodeTuple), LookupKey),
    {Key, Value} = element(N, NodeTuple),
    case less(Bt, LookupKey, Key) of
    true -&gt;
        % LookupKey is less than Key
        lookup_kvnode(Bt, NodeTuple, N, RestLookupKeys, [{LookupKey, not_found} | Output]);
    false -&gt;
        case less(Bt, Key, LookupKey) of
        true -&gt;
            % LookupKey is greater than Key
            lookup_kvnode(Bt, NodeTuple, N+1, RestLookupKeys, [{LookupKey, not_found} | Output]);
        false -&gt;
            % LookupKey is equal to Key
            lookup_kvnode(Bt, NodeTuple, N, RestLookupKeys, 
                  [{LookupKey, {ok, assemble(Bt, LookupKey, Value)}} | Output])
        end
    end.

</pre>





<pre class="example">
complete_root(_Bt, []) -&gt;
    {ok, nil};
complete_root(_Bt, [{_Key, PointerInfo}])-&gt;
    {ok, PointerInfo};
complete_root(Bt, KPs) -&gt;
    {ok, ResultKeyPointers} = write_node(Bt, kp_node, KPs),
    complete_root(Bt, ResultKeyPointers).

</pre>





<pre class="example">
%%%%%%%%%%%%% The chunkify function sucks! %%%%%%%%%%%%%
% It is inaccurate as it does not account for compression when blocks are
% written. Plus with the "case byte_size(term_to_binary(InList)) of" code
% it's probably really inefficient.

chunkify(InList) -&gt;
    case ?term_size(InList) of
    Size when Size &gt; ?CHUNK_THRESHOLD -&gt;
        NumberOfChunksLikely = ((Size div ?CHUNK_THRESHOLD) + 1),
        ChunkThreshold = Size div NumberOfChunksLikely,
        chunkify(InList, ChunkThreshold, [], 0, []);
    _Else -&gt;
        [InList]
    end.

chunkify([], _ChunkThreshold, [], 0, OutputChunks) -&gt;
    lists:reverse(OutputChunks);
chunkify([], _ChunkThreshold, OutList, _OutListSize, OutputChunks) -&gt;
    lists:reverse([lists:reverse(OutList) | OutputChunks]);
chunkify([InElement | RestInList], ChunkThreshold, OutList, OutListSize, OutputChunks) -&gt;
    case ?term_size(InElement) of
    Size when (Size + OutListSize) &gt; ChunkThreshold andalso OutList /= [] -&gt;
        chunkify(RestInList, ChunkThreshold, [], 0, [lists:reverse([InElement | OutList]) | OutputChunks]);
    Size -&gt;
        chunkify(RestInList, ChunkThreshold, [InElement | OutList], OutListSize + Size, OutputChunks)
    end.

</pre>





<pre class="example">
modify_node(Bt, RootPointerInfo, Actions, QueryOutput) -&gt;
    case RootPointerInfo of
    nil -&gt;
        NodeType = kv_node,
        NodeList = [];
    _Tuple -&gt;
        Pointer = element(1, RootPointerInfo),
        {NodeType, NodeList} = get_node(Bt, Pointer)
    end,
    NodeTuple = list_to_tuple(NodeList),

    {ok, NewNodeList, QueryOutput2} =
    case NodeType of
    kp_node -&gt; modify_kpnode(Bt, NodeTuple, 1, Actions, [], QueryOutput);
    kv_node -&gt; modify_kvnode(Bt, NodeTuple, 1, Actions, [], QueryOutput)
    end,
    case NewNodeList of
    [] -&gt;  % no nodes remain
        {ok, [], QueryOutput2};
    NodeList -&gt;  % nothing changed
        {LastKey, _LastValue} = element(tuple_size(NodeTuple), NodeTuple),
        {ok, [{LastKey, RootPointerInfo}], QueryOutput2};
    _Else2 -&gt;
        {ok, ResultList} = write_node(Bt, NodeType, NewNodeList),
        {ok, ResultList, QueryOutput2}
    end.

</pre>





<pre class="example">
reduce_node(#btree{reduce=nil}, _NodeType, _NodeList) -&gt;
    [];
reduce_node(#btree{reduce=R}, kp_node, NodeList) -&gt;
    R(rereduce, [element(2, Node) || {_K, Node} &lt;- NodeList]);
reduce_node(#btree{reduce=R}=Bt, kv_node, NodeList) -&gt;
    R(reduce, [assemble(Bt, K, V) || {K, V} &lt;- NodeList]).

</pre>





<pre class="example">
reduce_tree_size(kv_node, NodeSize, _KvList) -&gt;
    NodeSize;
reduce_tree_size(kp_node, NodeSize, []) -&gt;
    NodeSize;
reduce_tree_size(kp_node, _NodeSize, [{_K, {_P, _Red}} | _]) -&gt;
    % pre 1.2 format
    nil;
reduce_tree_size(kp_node, _NodeSize, [{_K, {_P, _Red, nil}} | _]) -&gt;
    nil;
reduce_tree_size(kp_node, NodeSize, [{_K, {_P, _Red, Sz}} | NodeList]) -&gt;
    reduce_tree_size(kp_node, NodeSize + Sz, NodeList).

</pre>





<pre class="example">
get_node(#btree{fd = Fd}, NodePos) -&gt;
    {ok, {NodeType, NodeList}} = couch_file:pread_term(Fd, NodePos),
    {NodeType, NodeList}.

</pre>





<pre class="example">
write_node(#btree{fd = Fd, compression = Comp} = Bt, NodeType, NodeList) -&gt;
    % split up nodes into smaller sizes
    NodeListList = chunkify(NodeList),
    % now write out each chunk and return the KeyPointer pairs for those nodes
    ResultList = [
        begin
            {ok, Pointer, Size} = couch_file:append_term(
                Fd, {NodeType, ANodeList}, [{compression, Comp}]),
            {LastKey, _} = lists:last(ANodeList),
            SubTreeSize = reduce_tree_size(NodeType, Size, ANodeList),
            {LastKey, {Pointer, reduce_node(Bt, NodeType, ANodeList), SubTreeSize}}
        end ||
        ANodeList &lt;- NodeListList
    ],
    {ok, ResultList}.

</pre>





<pre class="example">
modify_kpnode(Bt, {}, _LowerBound, Actions, [], QueryOutput) -&gt;
    modify_node(Bt, nil, Actions, QueryOutput);
modify_kpnode(_Bt, NodeTuple, LowerBound, [], ResultNode, QueryOutput) -&gt;
    {ok, lists:reverse(ResultNode, bounded_tuple_to_list(NodeTuple, LowerBound,
            tuple_size(NodeTuple), [])), QueryOutput};
modify_kpnode(Bt, NodeTuple, LowerBound,
        [{_, FirstActionKey, _}|_]=Actions, ResultNode, QueryOutput) -&gt;
    Sz = tuple_size(NodeTuple),
    N = find_first_gteq(Bt, NodeTuple, LowerBound, Sz, FirstActionKey),
    case N =:= Sz of
    true  -&gt;
        % perform remaining actions on last node
        {_, PointerInfo} = element(Sz, NodeTuple),
        {ok, ChildKPs, QueryOutput2} =
            modify_node(Bt, PointerInfo, Actions, QueryOutput),
        NodeList = lists:reverse(ResultNode, bounded_tuple_to_list(NodeTuple, LowerBound,
            Sz - 1, ChildKPs)),
        {ok, NodeList, QueryOutput2};
    false -&gt;
        {NodeKey, PointerInfo} = element(N, NodeTuple),
        SplitFun = fun({_ActionType, ActionKey, _ActionValue}) -&gt;
                not less(Bt, NodeKey, ActionKey)
            end,
        {LessEqQueries, GreaterQueries} = lists:splitwith(SplitFun, Actions),
        {ok, ChildKPs, QueryOutput2} =
                modify_node(Bt, PointerInfo, LessEqQueries, QueryOutput),
        ResultNode2 = lists:reverse(ChildKPs, bounded_tuple_to_revlist(NodeTuple,
                LowerBound, N - 1, ResultNode)),
        modify_kpnode(Bt, NodeTuple, N+1, GreaterQueries, ResultNode2, QueryOutput2)
    end.

</pre>





<pre class="example">
bounded_tuple_to_revlist(_Tuple, Start, End, Tail) when Start &gt; End -&gt;
    Tail;
bounded_tuple_to_revlist(Tuple, Start, End, Tail) -&gt;
    bounded_tuple_to_revlist(Tuple, Start+1, End, [element(Start, Tuple)|Tail]).

bounded_tuple_to_list(Tuple, Start, End, Tail) -&gt;
    bounded_tuple_to_list2(Tuple, Start, End, [], Tail).

bounded_tuple_to_list2(_Tuple, Start, End, Acc, Tail) when Start &gt; End -&gt;
    lists:reverse(Acc, Tail);
bounded_tuple_to_list2(Tuple, Start, End, Acc, Tail) -&gt;
    bounded_tuple_to_list2(Tuple, Start + 1, End, [element(Start,
    Tuple) | Acc], Tail).

</pre>





<pre class="example">
find_first_gteq(_Bt, _Tuple, Start, End, _Key) when Start == End -&gt;
    End;
find_first_gteq(Bt, Tuple, Start, End, Key) -&gt;
    Mid = Start + ((End - Start) div 2),
    {TupleKey, _} = element(Mid, Tuple),
    case less(Bt, TupleKey, Key) of
    true -&gt;
        find_first_gteq(Bt, Tuple, Mid+1, End, Key);
    false -&gt;
        find_first_gteq(Bt, Tuple, Start, Mid, Key)
    end.

</pre>





<pre class="example">

modify_kvnode(_Bt, NodeTuple, LowerBound, [], ResultNode, QueryOutput) -&gt;
    {ok, lists:reverse(ResultNode, bounded_tuple_to_list(NodeTuple, LowerBound, tuple_size(NodeTuple), [])), QueryOutput};
modify_kvnode(Bt, NodeTuple, LowerBound, [{ActionType, ActionKey, ActionValue} | RestActions], ResultNode, QueryOutput) when LowerBound &gt; tuple_size(NodeTuple) -&gt;
    case ActionType of
    insert -&gt;
        modify_kvnode(Bt, NodeTuple, LowerBound, RestActions, [{ActionKey, ActionValue} | ResultNode], QueryOutput);
    remove -&gt;
        % just drop the action
        modify_kvnode(Bt, NodeTuple, LowerBound, RestActions, ResultNode, QueryOutput);
    fetch -&gt;
        % the key/value must not exist in the tree
        modify_kvnode(Bt, NodeTuple, LowerBound, RestActions, ResultNode, [{not_found, {ActionKey, nil}} | QueryOutput])
    end;
modify_kvnode(Bt, NodeTuple, LowerBound, [{ActionType, ActionKey, ActionValue} | RestActions], AccNode, QueryOutput) -&gt;
    N = find_first_gteq(Bt, NodeTuple, LowerBound, tuple_size(NodeTuple), ActionKey),
    {Key, Value} = element(N, NodeTuple),
    ResultNode =  bounded_tuple_to_revlist(NodeTuple, LowerBound, N - 1, AccNode),
    case less(Bt, ActionKey, Key) of
    true -&gt;
        case ActionType of
        insert -&gt;
            % ActionKey is less than the Key, so insert
            modify_kvnode(Bt, NodeTuple, N, RestActions, [{ActionKey, ActionValue} | ResultNode], QueryOutput);
        remove -&gt;
            % ActionKey is less than the Key, just drop the action
            modify_kvnode(Bt, NodeTuple, N, RestActions, ResultNode, QueryOutput);
        fetch -&gt;
            % ActionKey is less than the Key, the key/value must not exist in the tree
            modify_kvnode(Bt, NodeTuple, N, RestActions, ResultNode, [{not_found, {ActionKey, nil}} | QueryOutput])
        end;
    false -&gt;
        % ActionKey and Key are maybe equal.
        case less(Bt, Key, ActionKey) of
        false -&gt;
            case ActionType of
            insert -&gt;
                modify_kvnode(Bt, NodeTuple, N+1, RestActions, [{ActionKey, ActionValue} | ResultNode], QueryOutput);
            remove -&gt;
                modify_kvnode(Bt, NodeTuple, N+1, RestActions, ResultNode, QueryOutput);
            fetch -&gt;
                % ActionKey is equal to the Key, insert into the QueryOuput, but re-process the node
                % since an identical action key can follow it.
                modify_kvnode(Bt, NodeTuple, N, RestActions, ResultNode, [{ok, assemble(Bt, Key, Value)} | QueryOutput])
            end;
        true -&gt;
            modify_kvnode(Bt, NodeTuple, N + 1, [{ActionType, ActionKey, ActionValue} | RestActions], [{Key, Value} | ResultNode], QueryOutput)
        end
    end.

</pre>





<pre class="example">
reduce_stream_node(_Bt, _Dir, nil, _KeyStart, _KeyEnd, GroupedKey, GroupedKVsAcc,
        GroupedRedsAcc, _KeyGroupFun, _Fun, Acc) -&gt;
    {ok, Acc, GroupedRedsAcc, GroupedKVsAcc, GroupedKey};
reduce_stream_node(Bt, Dir, Node, KeyStart, KeyEnd, GroupedKey, GroupedKVsAcc,
        GroupedRedsAcc, KeyGroupFun, Fun, Acc) -&gt;
    P = element(1, Node),
    case get_node(Bt, P) of
    {kp_node, NodeList} -&gt;
        reduce_stream_kp_node(Bt, Dir, NodeList, KeyStart, KeyEnd, GroupedKey,
                GroupedKVsAcc, GroupedRedsAcc, KeyGroupFun, Fun, Acc);
    {kv_node, KVs} -&gt;
        reduce_stream_kv_node(Bt, Dir, KVs, KeyStart, KeyEnd, GroupedKey,
                GroupedKVsAcc, GroupedRedsAcc, KeyGroupFun, Fun, Acc)
    end.

reduce_stream_kv_node(Bt, Dir, KVs, KeyStart, KeyEnd,
                        GroupedKey, GroupedKVsAcc, GroupedRedsAcc,
                        KeyGroupFun, Fun, Acc) -&gt;

    GTEKeyStartKVs =
    case KeyStart of
    undefined -&gt;
        KVs;
    _ -&gt;
        lists:dropwhile(fun({Key,_}) -&gt; less(Bt, Key, KeyStart) end, KVs)
    end,
    KVs2 =
    case KeyEnd of
    undefined -&gt;
        GTEKeyStartKVs;
    _ -&gt;
        lists:takewhile(
            fun({Key,_}) -&gt;
                not less(Bt, KeyEnd, Key)
            end, GTEKeyStartKVs)
    end,
    reduce_stream_kv_node2(Bt, adjust_dir(Dir, KVs2), GroupedKey, GroupedKVsAcc, GroupedRedsAcc,
                        KeyGroupFun, Fun, Acc).


reduce_stream_kv_node2(_Bt, [], GroupedKey, GroupedKVsAcc, GroupedRedsAcc,
        _KeyGroupFun, _Fun, Acc) -&gt;
    {ok, Acc, GroupedRedsAcc, GroupedKVsAcc, GroupedKey};
reduce_stream_kv_node2(Bt, [{Key, Value}| RestKVs], GroupedKey, GroupedKVsAcc,
        GroupedRedsAcc, KeyGroupFun, Fun, Acc) -&gt;
    case GroupedKey of
    undefined -&gt;
        reduce_stream_kv_node2(Bt, RestKVs, Key,
                [assemble(Bt,Key,Value)], [], KeyGroupFun, Fun, Acc);
    _ -&gt;

        case KeyGroupFun(GroupedKey, Key) of
        true -&gt;
            reduce_stream_kv_node2(Bt, RestKVs, GroupedKey,
                [assemble(Bt,Key,Value)|GroupedKVsAcc], GroupedRedsAcc, KeyGroupFun,
                Fun, Acc);
        false -&gt;
            case Fun(GroupedKey, {GroupedKVsAcc, GroupedRedsAcc}, Acc) of
            {ok, Acc2} -&gt;
                reduce_stream_kv_node2(Bt, RestKVs, Key, [assemble(Bt,Key,Value)],
                    [], KeyGroupFun, Fun, Acc2);
            {stop, Acc2} -&gt;
                throw({stop, Acc2})
            end
        end
    end.

</pre>





<pre class="example">
reduce_stream_kp_node(Bt, Dir, NodeList, KeyStart, KeyEnd,
                        GroupedKey, GroupedKVsAcc, GroupedRedsAcc,
                        KeyGroupFun, Fun, Acc) -&gt;
    Nodes =
    case KeyStart of
    undefined -&gt;
        NodeList;
    _ -&gt;
        lists:dropwhile(
            fun({Key,_}) -&gt;
                less(Bt, Key, KeyStart)
            end, NodeList)
    end,
    NodesInRange =
    case KeyEnd of
    undefined -&gt;
        Nodes;
    _ -&gt;
        {InRange, MaybeInRange} = lists:splitwith(
            fun({Key,_}) -&gt;
                less(Bt, Key, KeyEnd)
            end, Nodes),
        InRange ++ case MaybeInRange of [] -&gt; []; [FirstMaybe|_] -&gt; [FirstMaybe] end
    end,
    reduce_stream_kp_node2(Bt, Dir, adjust_dir(Dir, NodesInRange), KeyStart, KeyEnd,
        GroupedKey, GroupedKVsAcc, GroupedRedsAcc, KeyGroupFun, Fun, Acc).


reduce_stream_kp_node2(Bt, Dir, [{_Key, NodeInfo} | RestNodeList], KeyStart, KeyEnd,
                        undefined, [], [], KeyGroupFun, Fun, Acc) -&gt;
    {ok, Acc2, GroupedRedsAcc2, GroupedKVsAcc2, GroupedKey2} =
            reduce_stream_node(Bt, Dir, NodeInfo, KeyStart, KeyEnd, undefined,
                [], [], KeyGroupFun, Fun, Acc),
    reduce_stream_kp_node2(Bt, Dir, RestNodeList, KeyStart, KeyEnd, GroupedKey2,
            GroupedKVsAcc2, GroupedRedsAcc2, KeyGroupFun, Fun, Acc2);
reduce_stream_kp_node2(Bt, Dir, NodeList, KeyStart, KeyEnd,
        GroupedKey, GroupedKVsAcc, GroupedRedsAcc, KeyGroupFun, Fun, Acc) -&gt;
    {Grouped0, Ungrouped0} = lists:splitwith(fun({Key,_}) -&gt;
        KeyGroupFun(GroupedKey, Key) end, NodeList),
    {GroupedNodes, UngroupedNodes} =
    case Grouped0 of
    [] -&gt;
        {Grouped0, Ungrouped0};
    _ -&gt;
        [FirstGrouped | RestGrouped] = lists:reverse(Grouped0),
        {RestGrouped, [FirstGrouped | Ungrouped0]}
    end,
    GroupedReds = [element(2, Node) || {_, Node} &lt;- GroupedNodes],
    case UngroupedNodes of
    [{_Key, NodeInfo}|RestNodes] -&gt;
        {ok, Acc2, GroupedRedsAcc2, GroupedKVsAcc2, GroupedKey2} =
            reduce_stream_node(Bt, Dir, NodeInfo, KeyStart, KeyEnd, GroupedKey,
                GroupedKVsAcc, GroupedReds ++ GroupedRedsAcc, KeyGroupFun, Fun, Acc),
        reduce_stream_kp_node2(Bt, Dir, RestNodes, KeyStart, KeyEnd, GroupedKey2,
                GroupedKVsAcc2, GroupedRedsAcc2, KeyGroupFun, Fun, Acc2);
    [] -&gt;
        {ok, Acc, GroupedReds ++ GroupedRedsAcc, GroupedKVsAcc, GroupedKey}
    end.
</pre>





<pre class="example">
adjust_dir(fwd, List) -&gt;
    List;
adjust_dir(rev, List) -&gt;
    lists:reverse(List).

</pre>





<pre class="example">

stream_node(Bt, Reds, Node, StartKey, InRange, Dir, Fun, Acc) -&gt;
    Pointer = element(1, Node),
    {NodeType, NodeList} = get_node(Bt, Pointer),
    case NodeType of
    kp_node -&gt;
        stream_kp_node(Bt, Reds, adjust_dir(Dir, NodeList), StartKey, InRange, Dir, Fun, Acc);
    kv_node -&gt;
        stream_kv_node(Bt, Reds, adjust_dir(Dir, NodeList), StartKey, InRange, Dir, Fun, Acc)
    end.

stream_node(Bt, Reds, Node, InRange, Dir, Fun, Acc) -&gt;
    Pointer = element(1, Node),
    {NodeType, NodeList} = get_node(Bt, Pointer),
    case NodeType of
    kp_node -&gt;
        stream_kp_node(Bt, Reds, adjust_dir(Dir, NodeList), InRange, Dir, Fun, Acc);
    kv_node -&gt;
        stream_kv_node2(Bt, Reds, [], adjust_dir(Dir, NodeList), InRange, Dir, Fun, Acc)
    end.

stream_kp_node(_Bt, _Reds, [], _InRange, _Dir, _Fun, Acc) -&gt;
    {ok, Acc};
stream_kp_node(Bt, Reds, [{Key, Node} | Rest], InRange, Dir, Fun, Acc) -&gt;
    Red = element(2, Node),
    case Fun(traverse, Key, Red, Acc) of
    {ok, Acc2} -&gt;
        case stream_node(Bt, Reds, Node, InRange, Dir, Fun, Acc2) of
        {ok, Acc3} -&gt;
            stream_kp_node(Bt, [Red | Reds], Rest, InRange, Dir, Fun, Acc3);
        {stop, LastReds, Acc3} -&gt;
            {stop, LastReds, Acc3}
        end;
    {skip, Acc2} -&gt;
        stream_kp_node(Bt, [Red | Reds], Rest, InRange, Dir, Fun, Acc2)
    end.

</pre>





<pre class="example">

drop_nodes(_Bt, Reds, _StartKey, []) -&gt;
    {Reds, []};
drop_nodes(Bt, Reds, StartKey, [{NodeKey, Node} | RestKPs]) -&gt;
    case less(Bt, NodeKey, StartKey) of
    true -&gt;
        drop_nodes(Bt, [element(2, Node) | Reds], StartKey, RestKPs);
    false -&gt;
        {Reds, [{NodeKey, Node} | RestKPs]}
    end.

</pre>





<pre class="example">

stream_kp_node(Bt, Reds, KPs, StartKey, InRange, Dir, Fun, Acc) -&gt;
    {NewReds, NodesToStream} =
    case Dir of
    fwd -&gt;
        % drop all nodes sorting before the key
        drop_nodes(Bt, Reds, StartKey, KPs);
    rev -&gt;
        % keep all nodes sorting before the key, AND the first node to sort after
        RevKPs = lists:reverse(KPs),
         case lists:splitwith(fun({Key, _Pointer}) -&gt; less(Bt, Key, StartKey) end, RevKPs) of
        {_RevsBefore, []} -&gt;
            % everything sorts before it
            {Reds, KPs};
        {RevBefore, [FirstAfter | Drop]} -&gt;
            {[element(2, Node) || {_K, Node} &lt;- Drop] ++ Reds,
                 [FirstAfter | lists:reverse(RevBefore)]}
        end
    end,
    case NodesToStream of
    [] -&gt;
        {ok, Acc};
    [{_Key, Node} | Rest] -&gt;
        case stream_node(Bt, NewReds, Node, StartKey, InRange, Dir, Fun, Acc) of
        {ok, Acc2} -&gt;
            Red = element(2, Node),
            stream_kp_node(Bt, [Red | NewReds], Rest, InRange, Dir, Fun, Acc2);
        {stop, LastReds, Acc2} -&gt;
            {stop, LastReds, Acc2}
        end
    end.
</pre>





<pre class="example">

stream_kv_node(Bt, Reds, KVs, StartKey, InRange, Dir, Fun, Acc) -&gt;
    DropFun =
    case Dir of
    fwd -&gt;
        fun({Key, _}) -&gt; less(Bt, Key, StartKey) end;
    rev -&gt;
        fun({Key, _}) -&gt; less(Bt, StartKey, Key) end
    end,
    {LTKVs, GTEKVs} = lists:splitwith(DropFun, KVs),
    AssembleLTKVs = [assemble(Bt,K,V) || {K,V} &lt;- LTKVs],
    stream_kv_node2(Bt, Reds, AssembleLTKVs, GTEKVs, InRange, Dir, Fun, Acc).

stream_kv_node2(_Bt, _Reds, _PrevKVs, [], _InRange, _Dir, _Fun, Acc) -&gt;
    {ok, Acc};
stream_kv_node2(Bt, Reds, PrevKVs, [{K,V} | RestKVs], InRange, Dir, Fun, Acc) -&gt;
    case InRange(K) of
    false -&gt;
        {stop, {PrevKVs, Reds}, Acc};
    true -&gt;
        AssembledKV = assemble(Bt, K, V),
        case Fun(visit, AssembledKV, {PrevKVs, Reds}, Acc) of
        {ok, Acc2} -&gt;
            stream_kv_node2(Bt, Reds, [AssembledKV | PrevKVs], RestKVs, InRange, Dir, Fun, Acc2);
        {stop, Acc2} -&gt;
            {stop, {PrevKVs, Reds}, Acc2}
        end
    end.
</pre>



</div>
</div>
<div id="postamble">
<p class="author"> Author: Robert Dionne
<a href="mailto:bitdiddle@apache.org">&lt;bitdiddle@apache.org&gt;</a>
</p>
<p class="date"> Date: 2011-12-19 Mon</p>
<p class="creator">HTML generated by org-mode 6.33x in emacs 23</p>
</div>
</div>
</body>
</html>
